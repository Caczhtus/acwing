# 第二章 数据结构

1. 单链表：邻接表（存储图和树）
2. 双链表：优化某些问题

## 单链表



## 双向链表：

```cpp
#include <iostream>
using namespace std;
const int N=100010;
int m;
int e[N], l[N], r[N], idx;
//初始化
void init()
{
    //0表示左端点，1表示右端点
    l[0]=1;
    r[1]=0;
    idx=2;
}
//在下标是k的点的右边插入x
void add(int k, int t)
{
    e[idx]=x;
    r[idx]=r[k];
    l[idx]=k;
    r[k]=idx;
    l[r[k]]=idx++;
}

//删除
void remove(int k)
{
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
```

邻接表：即把每个点的所有邻边都存下来，即开了个单链表来保存点的所有邻边；

## 栈

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int stk[N], tt;
//插入
stk[++tt]=x;
//弹出
tt--;
//判断栈是否为空
if(tt>0) not empty;
else empty;
//栈顶
stk[tt];
```

## 队列

```cpp
//hh为队头，tt为队尾
//在队尾插入元素，在队头弹出元素
int q[N],hh,tt=-1;
//插入
q[++tt]=x;
//弹出
hh++;
if(hh<=tt) not empty;
else empty;
//取出队头元素
q[hh]
```

## 单调栈

单调栈最常应用于：求每一个数左边比他小的且离他最近的数在什么地方。

时间复杂度为O(n)。

以此为例看一下单调栈问题如何考虑。（和双指针一样）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int n;
int stk[N],tt;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        while(tt && stk[tt]>=x) tt--;
        if(tt) cout<<stk[tt]<<" ";
        else cout<<-1<<endl;
        str[++tt]=x;
    }
    return 0;
}
```

## 单调队列

经典应用：求滑动窗口里面的最大值或者最小值；

```cpp
#include <iostream>
using namespace std;
const int N = 1e6+10;
int n,k;
int a[N], q[N];
int main()
{
    scanf("%d%d", &n, &k);
    for(int i=0;i<n;i++) scanf("%d", &a[i]);
    int hh=0, tt=-1;
    for(int i=0;i<n;i++)
    {
        if(hh<=tt && i-k+1>q[hh]) hh++;
        while(hh<=tt && a[q[tt]]>=a[i]) tt--;
        q[++tt]=i;
        if(i>=k-1) cout<<a[q[hh]]<<" ";
    }
    puts("");
    hh=0, tt=-1;
    for(int i=0;i<n;i++)
    {
        if(hh<=tt && i-k+1>q[hh]) hh++;
        while(hh<=tt && a[q[tt]]<=a[i]) tt--;
        q[++tt]=i;
        if(i>=k-1) cout<<a[q[hh]]<<" ";
    }
    puts("");
}
```

## KMP

KMP 用于解决字符串匹配的问题：

1. 先想一想暴力枚举是如何做的；
2. 如何去优化；

## Trie（单词查找树）

Trie：用来高效地存储和查找字符串集合的数据结构；

 ```CPP
 #include <bits/stdc++.h>
 using namespace std;
 const int N = 100010;
 int son[N][26];//trie树当中每个点的所有儿子
 int cnt[N];//以当前字母结尾的单词的个数
 int idx;//当前用到的下标
 // 下标是0的点既是根节点又是空节点
 char str[N];
 
 
 void insert(char str[])
 {
     int p=0;
     for(int i=0;str[i];i++)
     {
         int u=str[i]-'a';
         if(!son[p][u]) son[p][u]=++idx;
         p=son[p][u];
     }
     cnt[p]++;
 }
 
 int query(char str[])
 {
     int p=0;
     for(int i=0;str[i];i++)
     {
         int u=str[i]-'a';
         if(!son[p][u]) return 0;
         p=son[p][u];
     }
     return cnt[p];
 }
 
 int main()
 {
     int n;
     cin>>n;
     while(n--)
     {
         char cmd;
         cin>>cmd;
         cin>>str;
         if(cmd=='I') insert(str);
         else cout<<query(str)<<endl;
     }
 }
 
 ```



## 并查集

并查集用于：

1. 将两个集合合并；
2. 询问两个元素是否在一个集合当中；

近乎O(1)；

基本原理：每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点；

问题1：如何判断树根：if(p[x]==x)

问题2：如何求x的集合编号：while(p[x]!=x) x=p[x];

问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号，那么p[px]=py；

路径压缩；

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100010;
int n,m;
int p[N];

int find(int x)
{
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) p[i]=i;
    while(m--)
    {
        char op[2];
        int a,b;
        cin>>op>>a>>b;
        if(op[0]=='M') p[find(a)]=find(b);
        else
        {
            if(find(a)==find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

## 堆

如何手写一个堆？

堆用于维护一个数据集合，堆的操作如下：

1. 向集合中插入一个数；heap[++size]=x; up(size);
2. 求这个集合中的最小值；heap[1];
3. 删除最小值；heap[1]=heap[size--]; down(1);

以上三个在操作时STL的堆当中可以支持的操作；

4. 删除任意一个元素；heap[k]=heap[size--]; down(k); up(k);
5. 修改任意一个元素；heap[k]=x; down(k); up(k);

堆是一个完全二叉树（出了最后一层节点外，上面的所有节点都是满的，最后一寸节点从前往后排列的）；

以小根堆为例：所有的节点的值都小于等于它的两个儿子节点的值；

堆是一种全新的存储方式，用一种一维数组来存；

一号点是根节点；

节点x的左儿子是2x，节点x的右儿子是2x+1，那么可以用

两个基本操作：down 和 up

## 哈希表

1. 存储结构（开放寻址法、拉链法）
2. 字符串哈希方式

## STL



