# 第二章 数据结构

1. 单链表：邻接表（存储图和树）
2. 双链表：优化某些问题

## 单链表



## 双向链表：

```cpp
#include <iostream>
using namespace std;
const int N=100010;
int m;
int e[N], l[N], r[N], idx;
//初始化
void init()
{
    //0表示左端点，1表示右端点
    l[0]=1;
    r[1]=0;
    idx=2;
}
//在下标是k的点的右边插入x
void add(int k, int t)
{
    e[idx]=x;
    r[idx]=r[k];
    l[idx]=k;
    r[k]=idx;
    l[r[k]]=idx++;
}

//删除
void remove(int k)
{
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
```

邻接表：即把每个点的所有邻边都存下来，即开了个单链表来保存点的所有邻边；

## 栈

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int stk[N], tt;
//插入
stk[++tt]=x;
//弹出
tt--;
//判断栈是否为空
if(tt>0) not empty;
else empty;
//栈顶
stk[tt];
```

## 队列

```cpp
//hh为队头，tt为队尾
//在队尾插入元素，在队头弹出元素
int q[N],hh,tt=-1;
//插入
q[++tt]=x;
//弹出
hh++;
if(hh<=tt) not empty;
else empty;
//取出队头元素
q[hh]
```

## 单调栈

单调栈最常应用于：求每一个数左边比他小的且离他最近的数在什么地方。

时间复杂度为O(n)。

以此为例看一下单调栈问题如何考虑。（和双指针一样）。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int n;
int stk[N],tt;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        while(tt && stk[tt]>=x) tt--;
        if(tt) cout<<stk[tt]<<" ";
        else cout<<-1<<endl;
        str[++tt]=x;
    }
    return 0;
}
```

## 单调队列

经典应用：求滑动窗口里面的最大值或者最小值；

```cpp
#include <iostream>
using namespace std;
const int N = 1e6+10;
int n,k;
int a[N], q[N];
int main()
{
    scanf("%d%d", &n, &k);
    for(int i=0;i<n;i++) scanf("%d", &a[i]);
    int hh=0, tt=-1;
    for(int i=0;i<n;i++)
    {
        if(hh<=tt && i-k+1>q[hh]) hh++;
        while(hh<=tt && a[q[tt]]>=a[i]) tt--;
        q[++tt]=i;
        if(i>=k-1) cout<<a[q[hh]]<<" ";
    }
    puts("");
    hh=0, tt=-1;
    for(int i=0;i<n;i++)
    {
        if(hh<=tt && i-k+1>q[hh]) hh++;
        while(hh<=tt && a[q[tt]]<=a[i]) tt--;
        q[++tt]=i;
        if(i>=k-1) cout<<a[q[hh]]<<" ";
    }
    puts("");
}
```

## KMP

KMP 用于解决字符串匹配的问题：

1. 先想一想暴力枚举是如何做的；
2. 如何去优化；

## Trie（单词查找树）

Trie：用来高效地存储和查找字符串集合的数据结构；

## 并查集

并查集用于：

1. 将两个集合合并；
2. 询问两个元素是否在一个集合当中；

近乎O(1)

基本原理：每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点；

问题1：如何判断树根：if(p[x]==x)

问题2：如何求x的集合编号：while(p[x]!=x) x=p[x];

问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号，那么p[x]=y集合；



