# 第三章 搜索与图论

1. 深度优先搜索（DFS）
2. 宽度优先搜索（BFS）
3. 树与图的存储
4. 树与图的深度优先遍历
5. 树与图的宽度优先遍历
6. 拓扑排序

## DFS

DFS和BFS的搜索结构都是树，但是搜索顺序不同。

DFS会尽可能往深处搜索，搜到叶子结点就会回溯，每次回溯完就会继续看当前是否所有路径都遍历过了？

#### Acwing_842 排列数字

![Screen Shot 2021-08-29 at 03.01.33](https://tva1.sinaimg.cn/large/008i3skNly1gtx3cf1r4tj61820u076a02.jpg)

```cpp
#include <iostream>
using namespace std;
const int N=10;
int n;
int path[N];//全局数组来存一个状态
//看第i个位置的时候，需要知道哪些数字被用过了
bool st[N];//st[k]为true时，意味着k被用过了

void dfs(int u)//dfs(i)即打印从第i个位置开始的所有可能路径
{
    if(u==n)//当看第n个位置的时候，说明位置已经全部填满了
    {
        for(int i=0;i<n;i++) printf("%d ", path[i]);
        puts("");
        return;
    }
    for(int i=1;i<=n;i++)
        if(!st[i])
        {
            path[u]=i;
            st[i]=true;//i被用过
            dfs(u+1);//从u+1个位置开始全部可能路径都走完了
            st[i]=false;//回溯并恢复
        }
    
}
int main()
{
    cin>>n;
    dfs(0);//从第0个位置开始看
    return 0;
}
```

### Acwing_843 n-皇后问题

![Screen Shot 2021-08-29 at 03.26.31](https://tva1.sinaimg.cn/large/008i3skNly1gtx42c5wc3j60n70b275902.jpg)

![Screen Shot 2021-08-29 at 03.26.49](https://tva1.sinaimg.cn/large/008i3skNly1gtx42nvgh1j60o60k3t9q02.jpg)

==**重点是剪枝的概念；**==

方法1：

```cpp
#include <iostream>
using namespace std;
const int N=20;
int n;
char g[N][N];//二维数组来存一个可能的解

//看到某行的时候，需要知道哪些列不满足要求
bool col[N];//row[k]为true时，意味着k列被用过了
bool dg[N];//df[k]为true时，意味着第k个正对角线被用过了
bool udg[N];//udf[k]为true时，意味着第k个反对角线被用过了

void dfs(int u)//dfs(i)即打印从第i行开始的所有可能解
{
    if(u==n)//当要看第n行的时候，说明位置已经全部填满了
    {
        for(int i=0;i<n;i++) puts(g[i]);
        puts("");
        return;
    }
    for(int i=0;i<n;i++)
        if(!col[i] && !dg[i+u] && !udg[n-1-i+u])
        {
            g[u][i]='Q';
            col[i]=true;//第i列被用过
            dg[u+i]=true;//第u+i个正对角线被用过
            udg[n-1-i+u]=true;//第n-1-i+u个正对角线被用过
            dfs(u+1);//从u+1个位置开始全部可能路径都走完了
            col[i]=false;//回溯并恢复
            dg[u+i]=false;
            udg[n-1-i+u]=false;
            g[u][i]='.';
        }
    
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            g[i][j]='.';
    dfs(0);//从第0个位置开始看
    return 0;
}
```

方法2：

第一种方法其实已经经过了一步抽象，即我们已经分析出了每一行只能有一个皇后，所以可以按行枚举，枚举每一行的皇后可以放到哪一列；

但是我们还可以用一种更原始的方式枚举皇后；

即一个格子一个格子地枚举；

```cpp
#include <iostream>
using namespace std;
const int N=20;
int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];

void dfs(int x, int y, int s)//从（x，y）开始搜索的可能解，之前已经摆了s个皇后
{
    if(y==n) y=0, x++;
    if(x==n)
    {
        if(s==n)
        {
            for(int i=0;i<n;i++) puts(g[i]);
            puts("");
        }
        return;
    }
    //枚举一下当前（x，y）格子的两种选择
    //1.不放皇后
    dfs(x, y+1, s);
    //2.放皇后
    if(!row[x] && !col[y] && !dg[x+y] && !udg[n-1-y+x])
    {
        g[x][y]='Q';
        row[x]=col[y]=dg[x+y]=udg[n-1-y+x]=true;
        dfs(x,y+1,s+1);
        row[x]=col[y]=dg[x+y]=udg[n-1-y+x]=false;
        g[x][y]='.';
    }
}

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
    g[i][j]='.';
    dfs(0, 0, 0);//从左上角开始搜索，并且记录当前有多少个皇后
    return 0;
}
```

## BFS

### Acwing_844 走迷宫

![Screen Shot 2021-08-31 at 16.56.55](https://tva1.sinaimg.cn/large/008i3skNly1gu02q7usmnj619q0ayabw02.jpg)

![Screen Shot 2021-08-31 at 16.57.14](https://tva1.sinaimg.cn/large/008i3skNly1gu02qh7oc2j61a80eawfp02.jpg)

![Screen Shot 2021-08-31 at 16.57.44](https://tva1.sinaimg.cn/large/008i3skNly1gu02qzx463j61b00fiwf102.jpg)

BFS有一个固定的框架：

```cpp
queue.push_back(init);
while(!queue.empty()):
{
    t=queue.popfront();
    t.extend();
}
```

DP问题和最短路问题其实是互通的。DP问题可以看作是一种特殊的最短路问题，是一种没有环的最短路问题。

并不是所有的最短路问题都可以拿BFS来做，只有当所有的边的权重都是1的时候才能用BFS。

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int ,int > PII;
const int N=110;
int n, m;
int g[N][N];//g数组为图
int d[N][N];//d数组存的每一个点到起点的距离
PII q[N*N];//手动实现队列


int bfs()//对g[N][N]进行广度优先搜索
{
    int hh=0, tt=0;
    q[0]={0,0};
    memset(d, -1, sizeof d);//先把所有的距离触发成-1，表示这些点没有走过
    d[0][0]=0;//表示（0，0）已经走过了
    int dx[4]={-1,0,1,0};
    int dy[4]={0,1,0,-1};
    while(hh<=tt)
    {
        auto t=q[hh++];//每次取出来队头元素
        for(int i=0;i<4;i++)//每次枚举四个方向
        {
            int x=t.first+dx[i], y=t.second+dy[i];//表示沿着这四个方向走会走到哪里去
            if(x>=0 && x<n && y>=0 && y<m && g[x][y]==0 && d[x][y]==-1)//第一次搜到的这个点才是最短距离
            {
                d[x][y]=d[t.first][t.second]+1;//到起点的距离加1
                q[++tt]={x,y};
            }
        }
    }
    return d[n-1][m-1];
}


int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
        cin>>g[i][j];
    cout<<bfs()<<endl;
    return 0;
}
```

## 树与图的存储

一般来说，树和图有两种存储方式。树是一种特殊的图，即树是无环连通图。
图分为两种：有向图和无向图。

存储方式：

1. 邻接矩阵；
2. 邻接表（单链表）；

### Acwing_846 树的重心

![Screen Shot 2021-09-01 at 17.59.38](https://tva1.sinaimg.cn/large/008i3skNgy1gu1a5sg0tlj61ac0n877c02.jpg)

![Screen Shot 2021-09-01 at 17.59.59](https://tva1.sinaimg.cn/large/008i3skNgy1gu1a63qp0dj61770u0abz02.jpg)

